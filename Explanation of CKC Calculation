# Protocol Documentation

## Command Example

The command frame follows a fixed format:

| Byte Position | Description | Example Value | Notes |
|--------------|-------------|---------------|-------|
| 0-1 | **Header** | `0xFF 0x00` | Fixed header bytes |
| 2 | **Command Byte** | `0xA0` | Indicates function (e.g., modify data upload period) |
| 3-4 | **Data Bytes** | `0x01 0x2C` | Represents period in seconds (big-endian format). Example: `0x012C` = 300 seconds |
| 5-6 | **Checksum** | (Calculated) | Modbus CRC-16, low byte first |

**Example Frame:** `FF 00 A0 01 2C [CRC_Low] [CRC_High]`

## CRC Verification Explanation

Modbus CRC-16 calculation algorithm:

1. **Initialize** CRC register to `0xFFFF`
2. **XOR** next data byte with low byte of CRC register
3. **Process each bit** (8 times):
   - Right shift register by 1 bit
   - If shifted-out bit = 0: continue
   - If shifted-out bit = 1: XOR register with polynomial `0xA001`
4. **Repeat steps 2-3** for all bytes in frame
5. **Swap bytes**: Exchange high and low bytes of final CRC value

**Polynomial:** `0xA001` (hex) = `1010 0000 0000 0001` (binary)

## C Sample Code

```c
#include <stdio.h>

int main(void) {
    // Example Modbus RTU frame: 01 03 00 00 00 0A C5 CD
    unsigned short tmp = 0xffff;
    unsigned short val = 0;
    unsigned char buff[6] = {0};
    
    buff[0] = 0x01;  // Slave address
    buff[1] = 0x03;  // Function code (read holding registers)
    buff[2] = 0x00;  // Starting address high byte
    buff[3] = 0x00;  // Starting address low byte
    buff[4] = 0x00;  // Quantity high byte
    buff[5] = 0x0A;  // Quantity low byte (10 registers)
    
    for (int n = 0; n < 6; n++) {
        tmp = buff[n] ^ tmp;
        printf("XOR result: %x\n", tmp);
        
        for (int i = 0; i < 8; i++) {  // Process each bit (8 bits per byte)
            printf("Iteration: %d\tLSB: %d", i * n, tmp & 0x01);
            printf("\tCurrent tmp: %x\n", tmp);
            
            if (tmp & 0x01) {
                tmp = tmp >> 1;
                tmp = tmp ^ 0xa001;
            } else {
                tmp = tmp >> 1;
            }
        }
        printf("CRC after processing data %d: %x\n", n, tmp);
    }
    
    /* Swap high and low bytes */
    val = tmp >> 8;
    val = val | (tmp << 8);
    
    printf("Final CRC (swapped): %X\n", val);
    printf("Expected CRC: C5CD\n");
    
    return 0;
}
```

## Notes

- **Endianness**: Protocol uses big-endian for data, but Modbus CRC has low-byte-first output
- **Checksum Coverage**: CRC is calculated over all bytes except the CRC field itself
- **Polynomial**: Modbus uses `0xA001` polynomial (reversed form of `0x8005`)
